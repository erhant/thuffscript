import {writeFile} from 'fs/promises';
import {Body} from '../bodies';
import {Declaration} from '../declarables';

/** A Huff program. */
export class Program {
  entries: Body[];
  code: string | undefined;

  constructor(entry: Body | Body[]) {
    this.entries = Array.isArray(entry) ? entry : [entry];
  }

  /** Compile for the given entry points. */
  compile(
    fields: {
      /** Authors of this contract, usually "name <github-link>" */
      authors?: string[];
      /** SPDX license of the contract. */
      license?: string;
      /** Title of the contract. */
      title?: string;
      /** A short description of the contract. */
      comments?: string[];
      /** Include paths to external Huff codes. */
      includePaths?: string[];
    } = {}
  ) {
    // dont re-compile
    if (this.code) {
      return this;
    }

    const bodyQueue = this.entries;
    const declarations: {[x in Declaration['type']]: string[]} = {
      constant: [],
      error: [],
      event: [],
      function: [],
      table: [],
    };
    const bodies: string[] = [];

    while (bodyQueue.length !== 0) {
      const body = bodyQueue.pop()!;

      const comp = body.compile();
      bodies.push(comp.body);
      comp.declarables.forEach(d => {
        if (!d.isDeclared) {
          declarations[d.type].push(d.declare().decl);
        }
      });
      bodyQueue.push(...comp.macros.filter(m => !m.isCompiled));
    }

    const docs = [
      fields.title ? `/// @title ${fields.title}` : null,
      fields.license ? `/// @notice SPDX-License-Identifier: ${fields.license}` : null,
      fields.authors ? fields.authors.map(a => `/// @author ${a}`).join('\n') : null,
      fields.comments ? fields.comments.map(c => `/// @notice ${c}`).join('\n') : null,
      '/// @dev auto-generated by <https://github.com/erhant/thuffscript>',
    ];

    const includes = fields.includePaths ? fields.includePaths.map(p => `#include "${p}"`).join('\n') : null;

    const constants = declarations.constant.length
      ? `
////////////////////////////////////////////////////////////////
//                         CONSTANTS                          //
////////////////////////////////////////////////////////////////

${declarations.constant.join('\n')}`
      : null;

    // errors
    const errors = declarations.error.length
      ? `
////////////////////////////////////////////////////////////////
//                           ERRORS                           //
////////////////////////////////////////////////////////////////

${declarations.error.join('\n')}`
      : null;

    // events
    const events = declarations.event.length
      ? `
////////////////////////////////////////////////////////////////
//                           EVENTS                           //
////////////////////////////////////////////////////////////////

${declarations.event.join('\n')}`
      : null;

    // functions
    const functions = declarations.function.length
      ? `
////////////////////////////////////////////////////////////////
//                          FUNCTIONS                         //
////////////////////////////////////////////////////////////////

${declarations.function.join('\n')}`
      : null;

    const macroBodies = `
////////////////////////////////////////////////////////////////
//                            MACROS                          //
////////////////////////////////////////////////////////////////

${bodies.reverse().join('\n\n')}
`;

    this.code = [...docs, includes, constants, errors, events, functions, macroBodies]
      .filter(a => a !== null)
      .join('\n');

    return this;
  }

  /** Export compiled code. Will compile if not compiled already.  */
  async export(path: string) {
    if (!this.code) {
      this.compile();
    }

    await writeFile(path, this.code!);

    return this;
  }
}
